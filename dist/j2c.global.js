var J2c = (function () {
'use strict';

var emptyObject = {};
var type = emptyObject.toString;
var ARRAY =  type.call([]);
var NUMBER = type.call(0);
var OBJECT = type.call(emptyObject);
var STRING = type.call('');
var FUNCTION = type.call(type);
var own =  emptyObject.hasOwnProperty;
var freeze = Object.freeze || function(o) {return o};


function defaults(target, source) {
  for (var k in source) if (own.call(source, k)) {
    if (k.indexOf('$') && !(k in target)) target[k] = source[k];
  }
  return target
}

function cartesian(a,b) {
  var res = [], i, j;
  for (j in b) if(own.call(b, j))
    for (i in a) if(own.call(a, i))
      res.push(a[i] + b[j]);
  return res
}

// "Tokenizes" the selectors into parts relevant for the next function.
// Strings and comments are matched, but ignored afterwards.
// This is not a full tokenizers. It only recognizes comas, parentheses,
// strings and comments.
// regexp generated by scripts/regexps.js then trimmed by hand
var selectorTokenizer = /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;


/**
 * This will split a coma-separated selector list into individual selectors,
 * ignoring comas in strings, comments and in :pseudo-selectors(parameter, lists).
 *
 * @param {string} selector
 * @return {string[]}
 */

function splitSelector(selector) {
  var indices = [], res = [], inParen = 0, o;
  /*eslint-disable no-cond-assign*/
  while (o = selectorTokenizer.exec(selector)) {
  /*eslint-enable no-cond-assign*/
    switch (o[0]) {
    case '(': inParen++; break
    case ')': inParen--; break
    case ',': if (inParen) break; indices.push(o.index);
    }
  }
  for (o = indices.length; o--;){
    res.unshift(selector.slice(indices[o] + 1));
    selector = selector.slice(0, indices[o]);
  }
  res.unshift(selector);
  return res
}

// Like the `selectorTokenizer`, but for the `&` operator
var ampersandTokenizer = /&|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;

function ampersand (selector, parents) {
  var indices = [], split = [], res, o;
  /*eslint-disable no-cond-assign*/
  while (o = ampersandTokenizer.exec(selector)) {
  /*eslint-enable no-cond-assign*/
    if (o[0] == '&') indices.push(o.index);
  }
  for (o = indices.length; o--;){
    split.unshift(selector.slice(indices[o] + 1));
    selector = selector.slice(0, indices[o]);
  }
  split.unshift(selector);
  if (split.length === 1) split.unshift('');
  res = [split[0]];
  for (o = 1; o < split.length; o++) {
    res = cartesian(res, cartesian(parents, [split[o]]));
  }
  return res.join(',')
}

function flatIter (f) {
  return function iter(arg) {
    if (type.call(arg) === ARRAY) for (var i= 0 ; i < arg.length; i ++) iter(arg[i]);
    else f(arg);
  }
}

var chars = '';
function randChars(n) {
  while(chars.length < n) chars += Math.floor(Math.random() * 0x100000000).toString(36);
  var res = '_' + chars.slice(0, n);
  chars = chars.slice(n);
  return res
}

function decamelize(match) {
  return '-' + match.toLowerCase()
}

/**
 * Handles the property:value; pairs.
 *
 * @param {object} state - holds the localizer- and walker-related methods
 *                         and state
 * @param {object} emit - the contextual emitters to the final buffer
 * @param {string} prefix - the current property or a prefix in case of nested
 *                          sub-properties.
 * @param {array|object|string} o - the declarations.
 * @param {boolean} local - are we in @local or in @global scope.
 */

function declarations(state, emit, prefix, o, local) {
  var k, v, kk;
  if (o==null) return

  switch ( type.call(o = o.valueOf()) ) {
  case ARRAY:
    for (k = 0; k < o.length; k++)

      declarations(state, emit, prefix, o[k], local);

    break
  case OBJECT:
    // prefix is falsy iif it is the empty string, which means we're at the root
    // of the declarations list.
    prefix = (prefix && prefix + '-');
    for (k in o) if (own.call(o, k)){
      v = o[k];
      if (/\$/.test(k)) {
        for (kk in (k = k.split('$'))) if (own.call(k, kk)) {

          declarations(state, emit, prefix + k[kk], v, local);

        }
      } else {

        declarations(state, emit, prefix + k, v, local);

      }
    }
    break
  default:
    // prefix is falsy when it is "", which means that we're
    // at the top level.
    // `o` is then treated as a `property:value` pair, or a
    // semi-colon-separated list thereof.
    if (!prefix) return emit.raw(o)

    // Otherwise, `prefix` is the property name, and
    // `o` is the value.

    // restore the dashes
    k = prefix.replace(/_/g, '-').replace(/[A-Z]/g, decamelize);

    if (local && (k == 'animation-name' || k == 'animation')) {
      // no need to tokenize here a plain `.split(',')` has all bases covered.
      // We may 'localize' a comment, but it's not a big deal.
      o = o.split(',').map(function (o) {

        return o.replace(/^\s*(?:(var\([^)]+\))|:?global\(\s*([_A-Za-z][-\w]*)\s*\)|()(-?[_A-Za-z][-\w]*))/, state.localizeReplacer)

      }).join(',');
    }

    emit.decl(k, o);
  }
}

/**
 * Handles a single at-rules
 *
 * @param {object} state - holds the localizer- and walker-related methods
 *                         and state
 * @param {object} emit - the contextual emitters to the final buffer
 * @param {array} k - The parsed at-rule, including the parameters,
 *                    if takes both parameters and a block.
 *                    k == [match, fullAtRule, atRuleType, params?]
 *                    So in `@-webkit-keyframes foo`, we have
 *                     - match = "@-webkit-keyframes foo"
 *                     - fullAtRule = "@-webkit-keyframes"
 *                     - atRuleType = "keyframes"
 *                     - params = "foo"
 * @param {string|string[]|object|object[]} v - Either parameters for
 *                                              block-less rules or
 *                                              their block
 *                                              for the others.
 * @param {string} prefix - the current selector or the selector prefix
 *                          in case of nested rules
 * @param {boolean} local - are we in @local or in @global scope?
 * @param {string} nestingDepth - are we nested in an at-rule or a selector?
 */

function atRules(state, emit, k, v, prefix, local, nestingDepth) {

  // First iterate over user-provided at-rules and return if one of them corresponds to the current one
  for (var i = 0; i < state.atruleHandlers.length; i++) {

    if (state.atruleHandlers[i](state, emit, k, v, prefix, local, nestingDepth)) return

  }

  // using `/^global$/.test(k[2])` rather that 'global' == k[2] gzips
  // slightly better thanks to the regexps tests further down.
  // It is slightly less efficient but this isn't a critical path.

  if (!k[3] && /^global$/.test(k[2])) {

    rules(state, emit, prefix, v, 0, nestingDepth);


  } else if (!k[3] && /^local$/.test(k[2])) {

    rules(state, emit, prefix, v, 1, nestingDepth);


  } else if (k[3] && /^adopt$/.test(k[2])) {

    if (!local || nestingDepth) return emit.err('@adopt global or nested: ' + k[0])

    if (!/^\.?[_A-Za-z][-\w]*$/.test(k[3])) return emit.err('bad adopter ' + JSON.stringify(k[3]) + ' in ' + k[0])

    i = [];
    flatIter(function(adoptee, asString) {

      if(adoptee == null || !/^\.?[_A-Za-z][-\w]*(?:\s+\.?[_A-Za-z][-\w]*)*$/.test(asString = adoptee + '')) emit.err('bad adoptee '+ JSON.stringify(adoptee) + ' in ' + k[0]);

      else i.push(asString.replace(/\./g, ''));

    })(v);

    // we may end up with duplicate classes but AFAIK it has no consequences on specificity.
    if (i.length) {
      state.localize(k[3] = k[3].replace(/\./g, ''));
      state.names[k[3]] += (' ' + i.join(' '));
    }


  } else if (!k[3] && /^(?:namespace|import|charset)$/.test(k[2])) {
    flatIter(function(v) {

      emit.atrule(k[1], k[2], v);

    })(v);


  } else if (!k[3] && /^(?:font-face|viewport)$/.test(k[2])) {
    flatIter(function(v) {

      emit.atrule(k[1], k[2], k[3], 'decl');

      declarations(state, emit, '', v, local);

      emit._atrule();

    })(v);

  } else if (k[3] && /^(?:media|supports|page|keyframes)$/.test(k[2])) {

    if (local && 'keyframes' == k[2]) {
      k[3] = k[3].replace(
        // generated by script/regexps.js
        /(var\([^)]+\))|:?global\(\s*([_A-Za-z][-\w]*)\s*\)|()(-?[_A-Za-z][-\w]*)/,
        state.localizeReplacer
      );
    }

    if ('page' == k[2]) {

      emit.atrule(k[1], k[2], k[3], 'decl');

      declarations(state, emit, '', v, local);

    } else {

      emit.atrule(k[1], k[2], k[3], 'rule');

      rules(
        state, emit,
        'keyframes' == k[2] ? '' : prefix,
        v, local, nestingDepth + 1
      );

    }

    emit._atrule();

  } else {

    emit.err('Unsupported at-rule: ' + k[0]);

  }
}

/**
 * Add rulesets and other CSS tree to the sheet.
 *
 * @param {object} state - holds the localizer- and walker-related methods
 *                         and state
 * @param {object} emit - the contextual emitters to the final buffer
 * @param {string} prefix - the current selector or a prefix in case of nested rules
 * @param {array|string|object} tree - a source object or sub-object.
 * @param {string} nestingDepth - are we nested in an at-rule?
 * @param {boolean} local - are we in @local or in @global scope?
 */
function rules(state, emit, prefix, tree, local, nestingDepth) {
  var k, v, inDeclaration, kk;

  switch (type.call(tree)) {

  case OBJECT:
    for (k in tree) if (own.call(tree, k)) {
      v = tree[k];

      if (prefix.length > 0 && /^[-\w$]+$/.test(k)) {
        if (!inDeclaration) {
          inDeclaration = 1;

          emit.rule(prefix);

        }
        if (/\$/.test(k)) {
          for (kk in (k = k.split('$'))) if (own.call(k, kk)) {

            declarations(state, emit, k[kk], v, local);

          }
        } else {

          declarations(state, emit, k, v, local);

        }

      } else if (/^@/.test(k)) {
        // Handle At-rules
        inDeclaration = 0;

        atRules(state, emit,
          /^(.(?:-[\w]+-)?([_A-Za-z][-\w]*))\b\s*([\s\S]*?)\s*$/.exec(k) || [k,'@','',''],
          v, prefix, local, nestingDepth
        );

      } else {
        // selector or nested sub-selectors
        inDeclaration = 0;

        if (k === '') {
          emit._rule();
          emit.err("Invalid selector ''");
          continue
        }

        rules(
          state, emit,
          // build the selector `prefix` for the next iteration.
          // ugly and full of redundant bits but so far the fastest/shortest.gz
          /*0 if*/(prefix.length > 0 && (/,/.test(prefix) || /,/.test(k))) ?

            /*0 then*/ (kk = splitSelector(prefix), splitSelector(
              local ?

                k.replace(
                  /("(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\/)|:global\(\s*(\.-?[_A-Za-z][-\w]*)\s*\)|(\.)(-?[_A-Za-z][-\w]*)/g,
                  state.localizeReplacer
                ) :

                k
            ).map(function (k) {
              return /&/.test(k) ? ampersand(k, kk) : kk.map(function(kk) {
                return kk + k
              }).join(',')
            }).join(',')) :

            /*0 else*/ /*1 if*/ /&/.test(k) ?

              /*1 then*/ ampersand(
                local ?

                  k.replace(
                    /("(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\/)|:global\(\s*(\.-?[_A-Za-z][-\w]*)\s*\)|(\.)(-?[_A-Za-z][-\w]*)/g,
                    state.localizeReplacer
                  ) :

                  k,
                [prefix]
              ) :

              /*1 else*/ prefix + (
                local ?

                  k.replace(
                    /("(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\/)|:global\(\s*(\.-?[_A-Za-z][-\w]*)\s*\)|(\.)(-?[_A-Za-z][-\w]*)/g,
                    state.localizeReplacer
                  ) :

                  k
                ),
           v, local, nestingDepth + 1
        );

      }
    }

    break

  case ARRAY:
    for (k = 0; k < tree.length; k++){

      rules(state, emit, prefix, tree[k], local, nestingDepth);

    }
    break

  case STRING:
    // CSS hacks or ouptut of `j2c.inline`. Even raw rulesets if in top position.

    if (prefix.length) emit.rule(prefix);

    emit.raw(tree);

  }
}

// This is the first entry in the filters array, which is
// actually the last step of the compiler. It inserts
// closing braces to close normal (non at-) rules (those
// that start with a selector). Doing it earlier is
// impossible without passing state around in unrelated code
// or ending up with duplicated selectors when the source tree
// contains arrays.
// There's no `_rule` handler, because the core compiler never
// calls it.
function closeSelectors(next, inline) {
  var lastSelector;
  return inline ? next : {
    init: function(){lastSelector = ''; next.init();},
    done: function () {
      if (lastSelector) {next._rule(); lastSelector = '';}
      return next.done()
    },
    atrule: function (rule, kind, param, takesBlock) {
      if (lastSelector) {next._rule(); lastSelector = '';}
      next.atrule(rule, kind, param, takesBlock);
    },
    _atrule: function (rule) {
      if (lastSelector) {next._rule(); lastSelector = '';}
      next._atrule(rule);
    },
    rule: function (selector) {
      if (selector !== lastSelector){
        if (lastSelector) next._rule();
        next.rule(selector);
        lastSelector = selector;
      }
    },
    _rule: function(){
      if (lastSelector) {next._rule(); lastSelector = '';}
    }
  }
}

function invoke(fn, tree, state, backend) {
  backend.init();
  try{
    fn(
      state,
      backend,
      '', // prefix
      tree,
      1,  // local, by default
      0   // nesting depth, only for sheet
    );
  } catch(e) {backend.err(e instanceof Error ? e.stack : '' + e);}
  return backend.done()
}

function makeInstance(prefix, suffix, atruleHandlers, nsCache, backend, setPropList) {
  var names = {};
  function localize(name) {
    if (!own.call(names, name)) names[name] = prefix + name + suffix;
    return names[name].match(/^\S+/)
  }
  var state =  {
    atruleHandlers: atruleHandlers,
    names: names,
    /**
     * Returns a localized version of a given name.
     * Registers the pair in `instnace.name` if needed.
     *
     * @param {string} name - the name to localize
     * @return {string} - the localized version
     */
    localize: localize,
    /**
     * Used as second argument for str.replace(localizeRegex, replacer)
     * `ignore`, `global` and `(dot, name)` are mutually exclusive
     *
     * @param {string} match - the whole match (ignored)
     * @param {string|null} ignore - a comment or a string literal
     * @param {string|null} global - a global name
     * @param {string|null} dot - either '.' for a local class name or the empty string otherwise
     * @param {string|null} name - the name to localize
     * @return {string}
     */
    localizeReplacer: function (match, ignore, global, dot, name) {
      return ignore || global || dot + localize(name)
    }
  };

  var instance = {
    ns: function(name) {
      var prefix = '__'+name.replace(/\W+/g, '_') + '_';
      if (!own.call(nsCache, prefix)) {
        nsCache[prefix] = makeInstance(prefix, suffix, atruleHandlers, nsCache, backend, setPropList);
      }
      return nsCache[prefix]
    },
    names: names,
    prefix: prefix,
    suffix: suffix,
    sheet: function(tree) {return invoke(rules, tree, state, backend[0])},
    inline: function (tree) {return invoke(declarations, tree, state, backend[1])}
  };
  for (var i = setPropList.length; i--;) defaults(instance, setPropList[i]);
  return instance
}

function J2c(options) {
  options = options || {};
  // the buffer that accumulates the output. Initialized in `$sink.init()`
  var buf, err;

  // the default sink.
  var _backend = [{
    init: function () {buf=[], err=[];},
    done: function (raw) {
      if (err.length != 0) throw new Error('j2c error(s): ' + JSON.stringify(err,null,2) + ' in context:\n' + buf.join(''))
      return raw ? buf : buf.join('')
    },
    err: function (msg) {
      err.push(msg);
      buf.push('/* +++ ERROR +++ ' + msg + ' */\n');
    },
    raw: function (str) {buf.push(str, '\n');},
    atrule: function (rule, kind, param, takesBlock) {
      buf.push(rule, param && ' ', param, takesBlock ? ' {\n' : ';\n');
    },
    // close atrule
    _atrule: function () {buf.push('}\n');},
    rule: function (selector) {buf.push(selector, ' {\n');},
    // close rule
    _rule: function () {buf.push('}\n');},
    decl: function (prop, value) {buf.push(prop, ':', value, ';\n');}
  }];

  // holds the `_filter` and `atrule` handlers
  var _filters = [closeSelectors];
  var _atruleHandlers = [];
  var _setPropList = [];
  var _suffix = randChars(7);
  var _nsCache = {};

  // the public API (see the main docs)


  // handler options
  if (type.call(options.plugins) === ARRAY) {
    flatIter(function(plugin) {
      if (type.call(plugin) !== OBJECT) throw new Error('bad plugin, object expected, got '+ type.call(plugin))

      if (type.call(plugin.filter) === FUNCTION) _filters.push(plugin.filter);
      if (type.call(plugin.atrule) === FUNCTION) _atruleHandlers.push(plugin.atrule);
      if (type.call(plugin.sink) === FUNCTION) _backend = plugin.sink();
      if (type.call(plugin.set) === OBJECT) _setPropList.push(plugin.set);
    })(options.plugins);
  }
  if (type.call(options.suffix) === STRING) _suffix = options.suffix;
  if (type.call(options.suffix) === NUMBER) _suffix = randChars(options.suffix);

  _backend[1] = _backend[1] || {
    init: _backend[0].init,
    done: _backend[0].done,
    raw: _backend[0].raw,
    err: _backend[0].err,
    decl: _backend[0].decl
  };

  // finalize the backend by merging in the filters
  for(var i = 0; i < 2; i++){ // 0 for j2c.sheet, 1 for j2c.inline
    for (var j = _filters.length; j--;) {
      _backend[i] = freeze(
        defaults(
          _filters[j](_backend[i], !!i),
          _backend[i]
        )
      );
    }
  }
  return freeze(makeInstance('', _suffix, _atruleHandlers, _nsCache, _backend, _setPropList))
}

return J2c;

}());

//data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9Vc2Vycy9weWd5L2Rldi9qMmMvajJjL3NyYy9oZWxwZXJzLmpzIiwiL1VzZXJzL3B5Z3kvZGV2L2oyYy9qMmMvc3JjL2RlY2xhcmF0aW9ucy5qcyIsIi9Vc2Vycy9weWd5L2Rldi9qMmMvajJjL3NyYy9hdC1ydWxlcy5qcyIsIi9Vc2Vycy9weWd5L2Rldi9qMmMvajJjL3NyYy9ydWxlcy5qcyIsIi9Vc2Vycy9weWd5L2Rldi9qMmMvajJjL3NyYy9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhclxuICBlbXB0eU9iamVjdCA9IHt9LFxuICB0eXBlID0gZW1wdHlPYmplY3QudG9TdHJpbmcsXG4gIEFSUkFZID0gIHR5cGUuY2FsbChbXSksXG4gIE5VTUJFUiA9IHR5cGUuY2FsbCgwKSxcbiAgT0JKRUNUID0gdHlwZS5jYWxsKGVtcHR5T2JqZWN0KSxcbiAgU1RSSU5HID0gdHlwZS5jYWxsKCcnKSxcbiAgRlVOQ1RJT04gPSB0eXBlLmNhbGwodHlwZSksXG4gIG93biA9ICBlbXB0eU9iamVjdC5oYXNPd25Qcm9wZXJ0eSxcbiAgZnJlZXplID0gT2JqZWN0LmZyZWV6ZSB8fCBmdW5jdGlvbihvKSB7cmV0dXJuIG99XG5cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIgayBpbiBzb3VyY2UpIGlmIChvd24uY2FsbChzb3VyY2UsIGspKSB7XG4gICAgaWYgKGsuaW5kZXhPZignJCcpICYmICEoayBpbiB0YXJnZXQpKSB0YXJnZXRba10gPSBzb3VyY2Vba11cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhbihhLGIpIHtcbiAgdmFyIHJlcyA9IFtdLCBpLCBqXG4gIGZvciAoaiBpbiBiKSBpZihvd24uY2FsbChiLCBqKSlcbiAgICBmb3IgKGkgaW4gYSkgaWYob3duLmNhbGwoYSwgaSkpXG4gICAgICByZXMucHVzaChhW2ldICsgYltqXSlcbiAgcmV0dXJuIHJlc1xufVxuXG4vLyBcIlRva2VuaXplc1wiIHRoZSBzZWxlY3RvcnMgaW50byBwYXJ0cyByZWxldmFudCBmb3IgdGhlIG5leHQgZnVuY3Rpb24uXG4vLyBTdHJpbmdzIGFuZCBjb21tZW50cyBhcmUgbWF0Y2hlZCwgYnV0IGlnbm9yZWQgYWZ0ZXJ3YXJkcy5cbi8vIFRoaXMgaXMgbm90IGEgZnVsbCB0b2tlbml6ZXJzLiBJdCBvbmx5IHJlY29nbml6ZXMgY29tYXMsIHBhcmVudGhlc2VzLFxuLy8gc3RyaW5ncyBhbmQgY29tbWVudHMuXG4vLyByZWdleHAgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcmVnZXhwcy5qcyB0aGVuIHRyaW1tZWQgYnkgaGFuZFxudmFyIHNlbGVjdG9yVG9rZW5pemVyID0gL1soKSxdfFwiKD86XFxcXC58W15cIlxcbl0pKlwifCcoPzpcXFxcLnxbXidcXG5dKSonfFxcL1xcKltcXHNcXFNdKj9cXCpcXC8vZ1xuXG5cbi8qKlxuICogVGhpcyB3aWxsIHNwbGl0IGEgY29tYS1zZXBhcmF0ZWQgc2VsZWN0b3IgbGlzdCBpbnRvIGluZGl2aWR1YWwgc2VsZWN0b3JzLFxuICogaWdub3JpbmcgY29tYXMgaW4gc3RyaW5ncywgY29tbWVudHMgYW5kIGluIDpwc2V1ZG8tc2VsZWN0b3JzKHBhcmFtZXRlciwgbGlzdHMpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cblxuZnVuY3Rpb24gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcikge1xuICB2YXIgaW5kaWNlcyA9IFtdLCByZXMgPSBbXSwgaW5QYXJlbiA9IDAsIG9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiovXG4gIHdoaWxlIChvID0gc2VsZWN0b3JUb2tlbml6ZXIuZXhlYyhzZWxlY3RvcikpIHtcbiAgLyplc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduKi9cbiAgICBzd2l0Y2ggKG9bMF0pIHtcbiAgICBjYXNlICcoJzogaW5QYXJlbisrOyBicmVha1xuICAgIGNhc2UgJyknOiBpblBhcmVuLS07IGJyZWFrXG4gICAgY2FzZSAnLCc6IGlmIChpblBhcmVuKSBicmVhazsgaW5kaWNlcy5wdXNoKG8uaW5kZXgpXG4gICAgfVxuICB9XG4gIGZvciAobyA9IGluZGljZXMubGVuZ3RoOyBvLS07KXtcbiAgICByZXMudW5zaGlmdChzZWxlY3Rvci5zbGljZShpbmRpY2VzW29dICsgMSkpXG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSgwLCBpbmRpY2VzW29dKVxuICB9XG4gIHJlcy51bnNoaWZ0KHNlbGVjdG9yKVxuICByZXR1cm4gcmVzXG59XG5cbi8vIExpa2UgdGhlIGBzZWxlY3RvclRva2VuaXplcmAsIGJ1dCBmb3IgdGhlIGAmYCBvcGVyYXRvclxudmFyIGFtcGVyc2FuZFRva2VuaXplciA9IC8mfFwiKD86XFxcXC58W15cIlxcbl0pKlwifCcoPzpcXFxcLnxbXidcXG5dKSonfFxcL1xcKltcXHNcXFNdKj9cXCpcXC8vZ1xuXG5mdW5jdGlvbiBhbXBlcnNhbmQgKHNlbGVjdG9yLCBwYXJlbnRzKSB7XG4gIHZhciBpbmRpY2VzID0gW10sIHNwbGl0ID0gW10sIHJlcywgb1xuICAvKmVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduKi9cbiAgd2hpbGUgKG8gPSBhbXBlcnNhbmRUb2tlbml6ZXIuZXhlYyhzZWxlY3RvcikpIHtcbiAgLyplc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduKi9cbiAgICBpZiAob1swXSA9PSAnJicpIGluZGljZXMucHVzaChvLmluZGV4KVxuICB9XG4gIGZvciAobyA9IGluZGljZXMubGVuZ3RoOyBvLS07KXtcbiAgICBzcGxpdC51bnNoaWZ0KHNlbGVjdG9yLnNsaWNlKGluZGljZXNbb10gKyAxKSlcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKDAsIGluZGljZXNbb10pXG4gIH1cbiAgc3BsaXQudW5zaGlmdChzZWxlY3RvcilcbiAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkgc3BsaXQudW5zaGlmdCgnJylcbiAgcmVzID0gW3NwbGl0WzBdXVxuICBmb3IgKG8gPSAxOyBvIDwgc3BsaXQubGVuZ3RoOyBvKyspIHtcbiAgICByZXMgPSBjYXJ0ZXNpYW4ocmVzLCBjYXJ0ZXNpYW4ocGFyZW50cywgW3NwbGl0W29dXSkpXG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCcsJylcbn1cblxuZnVuY3Rpb24gZmxhdEl0ZXIgKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXIoYXJnKSB7XG4gICAgaWYgKHR5cGUuY2FsbChhcmcpID09PSBBUlJBWSkgZm9yICh2YXIgaT0gMCA7IGkgPCBhcmcubGVuZ3RoOyBpICsrKSBpdGVyKGFyZ1tpXSlcbiAgICBlbHNlIGYoYXJnKVxuICB9XG59XG5cbnZhciBjaGFycyA9ICcnXG5mdW5jdGlvbiByYW5kQ2hhcnMobikge1xuICB3aGlsZShjaGFycy5sZW5ndGggPCBuKSBjaGFycyArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkudG9TdHJpbmcoMzYpXG4gIHZhciByZXMgPSAnXycgKyBjaGFycy5zbGljZSgwLCBuKVxuICBjaGFycyA9IGNoYXJzLnNsaWNlKG4pXG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IHtcbiAgQVJSQVksIEZVTkNUSU9OLCBOVU1CRVIsIE9CSkVDVCwgU1RSSU5HLFxuICBhbXBlcnNhbmQsIGNhcnRlc2lhbiwgZGVmYXVsdHMsXG4gIGZsYXRJdGVyLCBmcmVlemUsIG93bixcbiAgcmFuZENoYXJzLCBzcGxpdFNlbGVjdG9yLCB0eXBlXG59IiwiaW1wb3J0IHtvd24sIHR5cGUsIEFSUkFZLCBPQkpFQ1R9IGZyb20gJy4vaGVscGVycydcblxuZnVuY3Rpb24gZGVjYW1lbGl6ZShtYXRjaCkge1xuICByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHByb3BlcnR5OnZhbHVlOyBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBob2xkcyB0aGUgbG9jYWxpemVyLSBhbmQgd2Fsa2VyLXJlbGF0ZWQgbWV0aG9kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gZW1pdCAtIHRoZSBjb250ZXh0dWFsIGVtaXR0ZXJzIHRvIHRoZSBmaW5hbCBidWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggLSB0aGUgY3VycmVudCBwcm9wZXJ0eSBvciBhIHByZWZpeCBpbiBjYXNlIG9mIG5lc3RlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi1wcm9wZXJ0aWVzLlxuICogQHBhcmFtIHthcnJheXxvYmplY3R8c3RyaW5nfSBvIC0gdGhlIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWwgLSBhcmUgd2UgaW4gQGxvY2FsIG9yIGluIEBnbG9iYWwgc2NvcGUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyhzdGF0ZSwgZW1pdCwgcHJlZml4LCBvLCBsb2NhbCkge1xuICB2YXIgaywgdiwga2tcbiAgaWYgKG89PW51bGwpIHJldHVyblxuXG4gIHN3aXRjaCAoIHR5cGUuY2FsbChvID0gby52YWx1ZU9mKCkpICkge1xuICBjYXNlIEFSUkFZOlxuICAgIGZvciAoayA9IDA7IGsgPCBvLmxlbmd0aDsgaysrKVxuXG4gICAgICBkZWNsYXJhdGlvbnMoc3RhdGUsIGVtaXQsIHByZWZpeCwgb1trXSwgbG9jYWwpXG5cbiAgICBicmVha1xuICBjYXNlIE9CSkVDVDpcbiAgICAvLyBwcmVmaXggaXMgZmFsc3kgaWlmIGl0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHdoaWNoIG1lYW5zIHdlJ3JlIGF0IHRoZSByb290XG4gICAgLy8gb2YgdGhlIGRlY2xhcmF0aW9ucyBsaXN0LlxuICAgIHByZWZpeCA9IChwcmVmaXggJiYgcHJlZml4ICsgJy0nKVxuICAgIGZvciAoayBpbiBvKSBpZiAob3duLmNhbGwobywgaykpe1xuICAgICAgdiA9IG9ba11cbiAgICAgIGlmICgvXFwkLy50ZXN0KGspKSB7XG4gICAgICAgIGZvciAoa2sgaW4gKGsgPSBrLnNwbGl0KCckJykpKSBpZiAob3duLmNhbGwoaywga2spKSB7XG5cbiAgICAgICAgICBkZWNsYXJhdGlvbnMoc3RhdGUsIGVtaXQsIHByZWZpeCArIGtba2tdLCB2LCBsb2NhbClcblxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyhzdGF0ZSwgZW1pdCwgcHJlZml4ICsgaywgdiwgbG9jYWwpXG5cbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWtcbiAgZGVmYXVsdDpcbiAgICAvLyBwcmVmaXggaXMgZmFsc3kgd2hlbiBpdCBpcyBcIlwiLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gICAgLy8gYXQgdGhlIHRvcCBsZXZlbC5cbiAgICAvLyBgb2AgaXMgdGhlbiB0cmVhdGVkIGFzIGEgYHByb3BlcnR5OnZhbHVlYCBwYWlyLCBvciBhXG4gICAgLy8gc2VtaS1jb2xvbi1zZXBhcmF0ZWQgbGlzdCB0aGVyZW9mLlxuICAgIGlmICghcHJlZml4KSByZXR1cm4gZW1pdC5yYXcobylcblxuICAgIC8vIE90aGVyd2lzZSwgYHByZWZpeGAgaXMgdGhlIHByb3BlcnR5IG5hbWUsIGFuZFxuICAgIC8vIGBvYCBpcyB0aGUgdmFsdWUuXG5cbiAgICAvLyByZXN0b3JlIHRoZSBkYXNoZXNcbiAgICBrID0gcHJlZml4LnJlcGxhY2UoL18vZywgJy0nKS5yZXBsYWNlKC9bQS1aXS9nLCBkZWNhbWVsaXplKVxuXG4gICAgaWYgKGxvY2FsICYmIChrID09ICdhbmltYXRpb24tbmFtZScgfHwgayA9PSAnYW5pbWF0aW9uJykpIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gdG9rZW5pemUgaGVyZSBhIHBsYWluIGAuc3BsaXQoJywnKWAgaGFzIGFsbCBiYXNlcyBjb3ZlcmVkLlxuICAgICAgLy8gV2UgbWF5ICdsb2NhbGl6ZScgYSBjb21tZW50LCBidXQgaXQncyBub3QgYSBiaWcgZGVhbC5cbiAgICAgIG8gPSBvLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChvKSB7XG5cbiAgICAgICAgcmV0dXJuIG8ucmVwbGFjZSgvXlxccyooPzoodmFyXFwoW14pXStcXCkpfDo/Z2xvYmFsXFwoXFxzKihbX0EtWmEtel1bLVxcd10qKVxccypcXCl8KCkoLT9bX0EtWmEtel1bLVxcd10qKSkvLCBzdGF0ZS5sb2NhbGl6ZVJlcGxhY2VyKVxuXG4gICAgICB9KS5qb2luKCcsJylcbiAgICB9XG5cbiAgICBlbWl0LmRlY2woaywgbylcbiAgfVxufVxuIiwiaW1wb3J0IHtmbGF0SXRlcn0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHtydWxlc30gZnJvbSAnLi9ydWxlcydcbmltcG9ydCB7ZGVjbGFyYXRpb25zfSBmcm9tICcuL2RlY2xhcmF0aW9ucydcblxuLyoqXG4gKiBIYW5kbGVzIGEgc2luZ2xlIGF0LXJ1bGVzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gaG9sZHMgdGhlIGxvY2FsaXplci0gYW5kIHdhbGtlci1yZWxhdGVkIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGVtaXQgLSB0aGUgY29udGV4dHVhbCBlbWl0dGVycyB0byB0aGUgZmluYWwgYnVmZmVyXG4gKiBAcGFyYW0ge2FycmF5fSBrIC0gVGhlIHBhcnNlZCBhdC1ydWxlLCBpbmNsdWRpbmcgdGhlIHBhcmFtZXRlcnMsXG4gKiAgICAgICAgICAgICAgICAgICAgaWYgdGFrZXMgYm90aCBwYXJhbWV0ZXJzIGFuZCBhIGJsb2NrLlxuICogICAgICAgICAgICAgICAgICAgIGsgPT0gW21hdGNoLCBmdWxsQXRSdWxlLCBhdFJ1bGVUeXBlLCBwYXJhbXM/XVxuICogICAgICAgICAgICAgICAgICAgIFNvIGluIGBALXdlYmtpdC1rZXlmcmFtZXMgZm9vYCwgd2UgaGF2ZVxuICogICAgICAgICAgICAgICAgICAgICAtIG1hdGNoID0gXCJALXdlYmtpdC1rZXlmcmFtZXMgZm9vXCJcbiAqICAgICAgICAgICAgICAgICAgICAgLSBmdWxsQXRSdWxlID0gXCJALXdlYmtpdC1rZXlmcmFtZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAtIGF0UnVsZVR5cGUgPSBcImtleWZyYW1lc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIC0gcGFyYW1zID0gXCJmb29cIlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118b2JqZWN0fG9iamVjdFtdfSB2IC0gRWl0aGVyIHBhcmFtZXRlcnMgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay1sZXNzIHJ1bGVzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVpciBibG9ja1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBvdGhlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gdGhlIGN1cnJlbnQgc2VsZWN0b3Igb3IgdGhlIHNlbGVjdG9yIHByZWZpeFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGluIGNhc2Ugb2YgbmVzdGVkIHJ1bGVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsIC0gYXJlIHdlIGluIEBsb2NhbCBvciBpbiBAZ2xvYmFsIHNjb3BlP1xuICogQHBhcmFtIHtzdHJpbmd9IG5lc3RpbmdEZXB0aCAtIGFyZSB3ZSBuZXN0ZWQgaW4gYW4gYXQtcnVsZSBvciBhIHNlbGVjdG9yP1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhdFJ1bGVzKHN0YXRlLCBlbWl0LCBrLCB2LCBwcmVmaXgsIGxvY2FsLCBuZXN0aW5nRGVwdGgpIHtcblxuICAvLyBGaXJzdCBpdGVyYXRlIG92ZXIgdXNlci1wcm92aWRlZCBhdC1ydWxlcyBhbmQgcmV0dXJuIGlmIG9uZSBvZiB0aGVtIGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50IG9uZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmF0cnVsZUhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAoc3RhdGUuYXRydWxlSGFuZGxlcnNbaV0oc3RhdGUsIGVtaXQsIGssIHYsIHByZWZpeCwgbG9jYWwsIG5lc3RpbmdEZXB0aCkpIHJldHVyblxuXG4gIH1cblxuICAvLyB1c2luZyBgL15nbG9iYWwkLy50ZXN0KGtbMl0pYCByYXRoZXIgdGhhdCAnZ2xvYmFsJyA9PSBrWzJdIGd6aXBzXG4gIC8vIHNsaWdodGx5IGJldHRlciB0aGFua3MgdG8gdGhlIHJlZ2V4cHMgdGVzdHMgZnVydGhlciBkb3duLlxuICAvLyBJdCBpcyBzbGlnaHRseSBsZXNzIGVmZmljaWVudCBidXQgdGhpcyBpc24ndCBhIGNyaXRpY2FsIHBhdGguXG5cbiAgaWYgKCFrWzNdICYmIC9eZ2xvYmFsJC8udGVzdChrWzJdKSkge1xuXG4gICAgcnVsZXMoc3RhdGUsIGVtaXQsIHByZWZpeCwgdiwgMCwgbmVzdGluZ0RlcHRoKVxuXG5cbiAgfSBlbHNlIGlmICgha1szXSAmJiAvXmxvY2FsJC8udGVzdChrWzJdKSkge1xuXG4gICAgcnVsZXMoc3RhdGUsIGVtaXQsIHByZWZpeCwgdiwgMSwgbmVzdGluZ0RlcHRoKVxuXG5cbiAgfSBlbHNlIGlmIChrWzNdICYmIC9eYWRvcHQkLy50ZXN0KGtbMl0pKSB7XG5cbiAgICBpZiAoIWxvY2FsIHx8IG5lc3RpbmdEZXB0aCkgcmV0dXJuIGVtaXQuZXJyKCdAYWRvcHQgZ2xvYmFsIG9yIG5lc3RlZDogJyArIGtbMF0pXG5cbiAgICBpZiAoIS9eXFwuP1tfQS1aYS16XVstXFx3XSokLy50ZXN0KGtbM10pKSByZXR1cm4gZW1pdC5lcnIoJ2JhZCBhZG9wdGVyICcgKyBKU09OLnN0cmluZ2lmeShrWzNdKSArICcgaW4gJyArIGtbMF0pXG5cbiAgICBpID0gW11cbiAgICBmbGF0SXRlcihmdW5jdGlvbihhZG9wdGVlLCBhc1N0cmluZykge1xuXG4gICAgICBpZihhZG9wdGVlID09IG51bGwgfHwgIS9eXFwuP1tfQS1aYS16XVstXFx3XSooPzpcXHMrXFwuP1tfQS1aYS16XVstXFx3XSopKiQvLnRlc3QoYXNTdHJpbmcgPSBhZG9wdGVlICsgJycpKSBlbWl0LmVycignYmFkIGFkb3B0ZWUgJysgSlNPTi5zdHJpbmdpZnkoYWRvcHRlZSkgKyAnIGluICcgKyBrWzBdKVxuXG4gICAgICBlbHNlIGkucHVzaChhc1N0cmluZy5yZXBsYWNlKC9cXC4vZywgJycpKVxuXG4gICAgfSkodilcblxuICAgIC8vIHdlIG1heSBlbmQgdXAgd2l0aCBkdXBsaWNhdGUgY2xhc3NlcyBidXQgQUZBSUsgaXQgaGFzIG5vIGNvbnNlcXVlbmNlcyBvbiBzcGVjaWZpY2l0eS5cbiAgICBpZiAoaS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmxvY2FsaXplKGtbM10gPSBrWzNdLnJlcGxhY2UoL1xcLi9nLCAnJykpXG4gICAgICBzdGF0ZS5uYW1lc1trWzNdXSArPSAoJyAnICsgaS5qb2luKCcgJykpXG4gICAgfVxuXG5cbiAgfSBlbHNlIGlmICgha1szXSAmJiAvXig/Om5hbWVzcGFjZXxpbXBvcnR8Y2hhcnNldCkkLy50ZXN0KGtbMl0pKSB7XG4gICAgZmxhdEl0ZXIoZnVuY3Rpb24odikge1xuXG4gICAgICBlbWl0LmF0cnVsZShrWzFdLCBrWzJdLCB2KVxuXG4gICAgfSkodilcblxuXG4gIH0gZWxzZSBpZiAoIWtbM10gJiYgL14oPzpmb250LWZhY2V8dmlld3BvcnQpJC8udGVzdChrWzJdKSkge1xuICAgIGZsYXRJdGVyKGZ1bmN0aW9uKHYpIHtcblxuICAgICAgZW1pdC5hdHJ1bGUoa1sxXSwga1syXSwga1szXSwgJ2RlY2wnKVxuXG4gICAgICBkZWNsYXJhdGlvbnMoc3RhdGUsIGVtaXQsICcnLCB2LCBsb2NhbClcblxuICAgICAgZW1pdC5fYXRydWxlKClcblxuICAgIH0pKHYpXG5cbiAgfSBlbHNlIGlmIChrWzNdICYmIC9eKD86bWVkaWF8c3VwcG9ydHN8cGFnZXxrZXlmcmFtZXMpJC8udGVzdChrWzJdKSkge1xuXG4gICAgaWYgKGxvY2FsICYmICdrZXlmcmFtZXMnID09IGtbMl0pIHtcbiAgICAgIGtbM10gPSBrWzNdLnJlcGxhY2UoXG4gICAgICAgIC8vIGdlbmVyYXRlZCBieSBzY3JpcHQvcmVnZXhwcy5qc1xuICAgICAgICAvKHZhclxcKFteKV0rXFwpKXw6P2dsb2JhbFxcKFxccyooW19BLVphLXpdWy1cXHddKilcXHMqXFwpfCgpKC0/W19BLVphLXpdWy1cXHddKikvLFxuICAgICAgICBzdGF0ZS5sb2NhbGl6ZVJlcGxhY2VyXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCdwYWdlJyA9PSBrWzJdKSB7XG5cbiAgICAgIGVtaXQuYXRydWxlKGtbMV0sIGtbMl0sIGtbM10sICdkZWNsJylcblxuICAgICAgZGVjbGFyYXRpb25zKHN0YXRlLCBlbWl0LCAnJywgdiwgbG9jYWwpXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBlbWl0LmF0cnVsZShrWzFdLCBrWzJdLCBrWzNdLCAncnVsZScpXG5cbiAgICAgIHJ1bGVzKFxuICAgICAgICBzdGF0ZSwgZW1pdCxcbiAgICAgICAgJ2tleWZyYW1lcycgPT0ga1syXSA/ICcnIDogcHJlZml4LFxuICAgICAgICB2LCBsb2NhbCwgbmVzdGluZ0RlcHRoICsgMVxuICAgICAgKVxuXG4gICAgfVxuXG4gICAgZW1pdC5fYXRydWxlKClcblxuICB9IGVsc2Uge1xuXG4gICAgZW1pdC5lcnIoJ1Vuc3VwcG9ydGVkIGF0LXJ1bGU6ICcgKyBrWzBdKVxuXG4gIH1cbn1cbiIsImltcG9ydCB7dHlwZSwgQVJSQVksIE9CSkVDVCwgU1RSSU5HLCBhbXBlcnNhbmQsIG93biwgc3BsaXRTZWxlY3Rvcn0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHtkZWNsYXJhdGlvbnN9IGZyb20gJy4vZGVjbGFyYXRpb25zJ1xuaW1wb3J0IHthdFJ1bGVzfSBmcm9tICcuL2F0LXJ1bGVzJ1xuXG4vKipcbiAqIEFkZCBydWxlc2V0cyBhbmQgb3RoZXIgQ1NTIHRyZWUgdG8gdGhlIHNoZWV0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIGhvbGRzIHRoZSBsb2NhbGl6ZXItIGFuZCB3YWxrZXItcmVsYXRlZCBtZXRob2RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbWl0IC0gdGhlIGNvbnRleHR1YWwgZW1pdHRlcnMgdG8gdGhlIGZpbmFsIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCAtIHRoZSBjdXJyZW50IHNlbGVjdG9yIG9yIGEgcHJlZml4IGluIGNhc2Ugb2YgbmVzdGVkIHJ1bGVzXG4gKiBAcGFyYW0ge2FycmF5fHN0cmluZ3xvYmplY3R9IHRyZWUgLSBhIHNvdXJjZSBvYmplY3Qgb3Igc3ViLW9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXN0aW5nRGVwdGggLSBhcmUgd2UgbmVzdGVkIGluIGFuIGF0LXJ1bGU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsIC0gYXJlIHdlIGluIEBsb2NhbCBvciBpbiBAZ2xvYmFsIHNjb3BlP1xuICovXG5leHBvcnQgZnVuY3Rpb24gcnVsZXMoc3RhdGUsIGVtaXQsIHByZWZpeCwgdHJlZSwgbG9jYWwsIG5lc3RpbmdEZXB0aCkge1xuICB2YXIgaywgdiwgaW5EZWNsYXJhdGlvbiwga2tcblxuICBzd2l0Y2ggKHR5cGUuY2FsbCh0cmVlKSkge1xuXG4gIGNhc2UgT0JKRUNUOlxuICAgIGZvciAoayBpbiB0cmVlKSBpZiAob3duLmNhbGwodHJlZSwgaykpIHtcbiAgICAgIHYgPSB0cmVlW2tdXG5cbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoID4gMCAmJiAvXlstXFx3JF0rJC8udGVzdChrKSkge1xuICAgICAgICBpZiAoIWluRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBpbkRlY2xhcmF0aW9uID0gMVxuXG4gICAgICAgICAgZW1pdC5ydWxlKHByZWZpeClcblxuICAgICAgICB9XG4gICAgICAgIGlmICgvXFwkLy50ZXN0KGspKSB7XG4gICAgICAgICAgZm9yIChrayBpbiAoayA9IGsuc3BsaXQoJyQnKSkpIGlmIChvd24uY2FsbChrLCBraykpIHtcblxuICAgICAgICAgICAgZGVjbGFyYXRpb25zKHN0YXRlLCBlbWl0LCBrW2trXSwgdiwgbG9jYWwpXG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBkZWNsYXJhdGlvbnMoc3RhdGUsIGVtaXQsIGssIHYsIGxvY2FsKVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICgvXkAvLnRlc3QoaykpIHtcbiAgICAgICAgLy8gSGFuZGxlIEF0LXJ1bGVzXG4gICAgICAgIGluRGVjbGFyYXRpb24gPSAwXG5cbiAgICAgICAgYXRSdWxlcyhzdGF0ZSwgZW1pdCxcbiAgICAgICAgICAvXiguKD86LVtcXHddKy0pPyhbX0EtWmEtel1bLVxcd10qKSlcXGJcXHMqKFtcXHNcXFNdKj8pXFxzKiQvLmV4ZWMoaykgfHwgW2ssJ0AnLCcnLCcnXSxcbiAgICAgICAgICB2LCBwcmVmaXgsIGxvY2FsLCBuZXN0aW5nRGVwdGhcbiAgICAgICAgKVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZWxlY3RvciBvciBuZXN0ZWQgc3ViLXNlbGVjdG9yc1xuICAgICAgICBpbkRlY2xhcmF0aW9uID0gMFxuXG4gICAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICAgIGVtaXQuX3J1bGUoKVxuICAgICAgICAgIGVtaXQuZXJyKFwiSW52YWxpZCBzZWxlY3RvciAnJ1wiKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBydWxlcyhcbiAgICAgICAgICBzdGF0ZSwgZW1pdCxcbiAgICAgICAgICAvLyBidWlsZCB0aGUgc2VsZWN0b3IgYHByZWZpeGAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAvLyB1Z2x5IGFuZCBmdWxsIG9mIHJlZHVuZGFudCBiaXRzIGJ1dCBzbyBmYXIgdGhlIGZhc3Rlc3Qvc2hvcnRlc3QuZ3pcbiAgICAgICAgICAvKjAgaWYqLyhwcmVmaXgubGVuZ3RoID4gMCAmJiAoLywvLnRlc3QocHJlZml4KSB8fCAvLC8udGVzdChrKSkpID9cblxuICAgICAgICAgICAgLyowIHRoZW4qLyAoa2sgPSBzcGxpdFNlbGVjdG9yKHByZWZpeCksIHNwbGl0U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGxvY2FsID9cblxuICAgICAgICAgICAgICAgIGsucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgIC8oXCIoPzpcXFxcLnxbXlwiXFxuXSkqXCJ8Jyg/OlxcXFwufFteJ1xcbl0pKid8XFwvXFwqW1xcc1xcU10qP1xcKlxcLyl8Omdsb2JhbFxcKFxccyooXFwuLT9bX0EtWmEtel1bLVxcd10qKVxccypcXCl8KFxcLikoLT9bX0EtWmEtel1bLVxcd10qKS9nLFxuICAgICAgICAgICAgICAgICAgc3RhdGUubG9jYWxpemVSZXBsYWNlclxuICAgICAgICAgICAgICAgICkgOlxuXG4gICAgICAgICAgICAgICAga1xuICAgICAgICAgICAgKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KGspID8gYW1wZXJzYW5kKGssIGtrKSA6IGtrLm1hcChmdW5jdGlvbihraykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrayArIGtcbiAgICAgICAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICAgICB9KS5qb2luKCcsJykpIDpcblxuICAgICAgICAgICAgLyowIGVsc2UqLyAvKjEgaWYqLyAvJi8udGVzdChrKSA/XG5cbiAgICAgICAgICAgICAgLyoxIHRoZW4qLyBhbXBlcnNhbmQoXG4gICAgICAgICAgICAgICAgbG9jYWwgP1xuXG4gICAgICAgICAgICAgICAgICBrLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8oXCIoPzpcXFxcLnxbXlwiXFxuXSkqXCJ8Jyg/OlxcXFwufFteJ1xcbl0pKid8XFwvXFwqW1xcc1xcU10qP1xcKlxcLyl8Omdsb2JhbFxcKFxccyooXFwuLT9bX0EtWmEtel1bLVxcd10qKVxccypcXCl8KFxcLikoLT9bX0EtWmEtel1bLVxcd10qKS9nLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2NhbGl6ZVJlcGxhY2VyXG4gICAgICAgICAgICAgICAgICApIDpcblxuICAgICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBbcHJlZml4XVxuICAgICAgICAgICAgICApIDpcblxuICAgICAgICAgICAgICAvKjEgZWxzZSovIHByZWZpeCArIChcbiAgICAgICAgICAgICAgICBsb2NhbCA/XG5cbiAgICAgICAgICAgICAgICAgIGsucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgLyhcIig/OlxcXFwufFteXCJcXG5dKSpcInwnKD86XFxcXC58W14nXFxuXSkqJ3xcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKXw6Z2xvYmFsXFwoXFxzKihcXC4tP1tfQS1aYS16XVstXFx3XSopXFxzKlxcKXwoXFwuKSgtP1tfQS1aYS16XVstXFx3XSopL2csXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvY2FsaXplUmVwbGFjZXJcbiAgICAgICAgICAgICAgICAgICkgOlxuXG4gICAgICAgICAgICAgICAgICBrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgdiwgbG9jYWwsIG5lc3RpbmdEZXB0aCArIDFcbiAgICAgICAgKVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgYnJlYWtcblxuICBjYXNlIEFSUkFZOlxuICAgIGZvciAoayA9IDA7IGsgPCB0cmVlLmxlbmd0aDsgaysrKXtcblxuICAgICAgcnVsZXMoc3RhdGUsIGVtaXQsIHByZWZpeCwgdHJlZVtrXSwgbG9jYWwsIG5lc3RpbmdEZXB0aClcblxuICAgIH1cbiAgICBicmVha1xuXG4gIGNhc2UgU1RSSU5HOlxuICAgIC8vIENTUyBoYWNrcyBvciBvdXB0dXQgb2YgYGoyYy5pbmxpbmVgLiBFdmVuIHJhdyBydWxlc2V0cyBpZiBpbiB0b3AgcG9zaXRpb24uXG5cbiAgICBpZiAocHJlZml4Lmxlbmd0aCkgZW1pdC5ydWxlKHByZWZpeClcblxuICAgIGVtaXQucmF3KHRyZWUpXG5cbiAgfVxufVxuXG4vLyBUaGlzIGlzIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgZmlsdGVycyBhcnJheSwgd2hpY2ggaXNcbi8vIGFjdHVhbGx5IHRoZSBsYXN0IHN0ZXAgb2YgdGhlIGNvbXBpbGVyLiBJdCBpbnNlcnRzXG4vLyBjbG9zaW5nIGJyYWNlcyB0byBjbG9zZSBub3JtYWwgKG5vbiBhdC0pIHJ1bGVzICh0aG9zZVxuLy8gdGhhdCBzdGFydCB3aXRoIGEgc2VsZWN0b3IpLiBEb2luZyBpdCBlYXJsaWVyIGlzXG4vLyBpbXBvc3NpYmxlIHdpdGhvdXQgcGFzc2luZyBzdGF0ZSBhcm91bmQgaW4gdW5yZWxhdGVkIGNvZGVcbi8vIG9yIGVuZGluZyB1cCB3aXRoIGR1cGxpY2F0ZWQgc2VsZWN0b3JzIHdoZW4gdGhlIHNvdXJjZSB0cmVlXG4vLyBjb250YWlucyBhcnJheXMuXG4vLyBUaGVyZSdzIG5vIGBfcnVsZWAgaGFuZGxlciwgYmVjYXVzZSB0aGUgY29yZSBjb21waWxlciBuZXZlclxuLy8gY2FsbHMgaXQuXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VTZWxlY3RvcnMobmV4dCwgaW5saW5lKSB7XG4gIHZhciBsYXN0U2VsZWN0b3JcbiAgcmV0dXJuIGlubGluZSA/IG5leHQgOiB7XG4gICAgaW5pdDogZnVuY3Rpb24oKXtsYXN0U2VsZWN0b3IgPSAnJzsgbmV4dC5pbml0KCl9LFxuICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsYXN0U2VsZWN0b3IpIHtuZXh0Ll9ydWxlKCk7IGxhc3RTZWxlY3RvciA9ICcnfVxuICAgICAgcmV0dXJuIG5leHQuZG9uZSgpXG4gICAgfSxcbiAgICBhdHJ1bGU6IGZ1bmN0aW9uIChydWxlLCBraW5kLCBwYXJhbSwgdGFrZXNCbG9jaykge1xuICAgICAgaWYgKGxhc3RTZWxlY3Rvcikge25leHQuX3J1bGUoKTsgbGFzdFNlbGVjdG9yID0gJyd9XG4gICAgICBuZXh0LmF0cnVsZShydWxlLCBraW5kLCBwYXJhbSwgdGFrZXNCbG9jaylcbiAgICB9LFxuICAgIF9hdHJ1bGU6IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAobGFzdFNlbGVjdG9yKSB7bmV4dC5fcnVsZSgpOyBsYXN0U2VsZWN0b3IgPSAnJ31cbiAgICAgIG5leHQuX2F0cnVsZShydWxlKVxuICAgIH0sXG4gICAgcnVsZTogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgIT09IGxhc3RTZWxlY3Rvcil7XG4gICAgICAgIGlmIChsYXN0U2VsZWN0b3IpIG5leHQuX3J1bGUoKVxuICAgICAgICBuZXh0LnJ1bGUoc2VsZWN0b3IpXG4gICAgICAgIGxhc3RTZWxlY3RvciA9IHNlbGVjdG9yXG4gICAgICB9XG4gICAgfSxcbiAgICBfcnVsZTogZnVuY3Rpb24oKXtcbiAgICAgIGlmIChsYXN0U2VsZWN0b3IpIHtuZXh0Ll9ydWxlKCk7IGxhc3RTZWxlY3RvciA9ICcnfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtkZWZhdWx0cywgZmxhdEl0ZXIsIGZyZWV6ZSwgcmFuZENoYXJzLCBvd24sIHR5cGUsIEFSUkFZLCBGVU5DVElPTiwgTlVNQkVSLCBPQkpFQ1QsIFNUUklOR30gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHtjbG9zZVNlbGVjdG9ycywgcnVsZXN9IGZyb20gJy4vcnVsZXMnXG5pbXBvcnQge2RlY2xhcmF0aW9uc30gZnJvbSAnLi9kZWNsYXJhdGlvbnMnXG5cbmZ1bmN0aW9uIGludm9rZShmbiwgdHJlZSwgc3RhdGUsIGJhY2tlbmQpIHtcbiAgYmFja2VuZC5pbml0KClcbiAgdHJ5e1xuICAgIGZuKFxuICAgICAgc3RhdGUsXG4gICAgICBiYWNrZW5kLFxuICAgICAgJycsIC8vIHByZWZpeFxuICAgICAgdHJlZSxcbiAgICAgIDEsICAvLyBsb2NhbCwgYnkgZGVmYXVsdFxuICAgICAgMCAgIC8vIG5lc3RpbmcgZGVwdGgsIG9ubHkgZm9yIHNoZWV0XG4gICAgKVxuICB9IGNhdGNoKGUpIHtiYWNrZW5kLmVycihlIGluc3RhbmNlb2YgRXJyb3IgPyBlLnN0YWNrIDogJycgKyBlKX1cbiAgcmV0dXJuIGJhY2tlbmQuZG9uZSgpXG59XG5cbmZ1bmN0aW9uIG1ha2VJbnN0YW5jZShwcmVmaXgsIHN1ZmZpeCwgYXRydWxlSGFuZGxlcnMsIG5zQ2FjaGUsIGJhY2tlbmQsIHNldFByb3BMaXN0KSB7XG4gIHZhciBuYW1lcyA9IHt9XG4gIGZ1bmN0aW9uIGxvY2FsaXplKG5hbWUpIHtcbiAgICBpZiAoIW93bi5jYWxsKG5hbWVzLCBuYW1lKSkgbmFtZXNbbmFtZV0gPSBwcmVmaXggKyBuYW1lICsgc3VmZml4XG4gICAgcmV0dXJuIG5hbWVzW25hbWVdLm1hdGNoKC9eXFxTKy8pXG4gIH1cbiAgdmFyIHN0YXRlID0gIHtcbiAgICBhdHJ1bGVIYW5kbGVyczogYXRydWxlSGFuZGxlcnMsXG4gICAgbmFtZXM6IG5hbWVzLFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgdmVyc2lvbiBvZiBhIGdpdmVuIG5hbWUuXG4gICAgICogUmVnaXN0ZXJzIHRoZSBwYWlyIGluIGBpbnN0bmFjZS5uYW1lYCBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIHRvIGxvY2FsaXplXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBsb2NhbGl6ZWQgdmVyc2lvblxuICAgICAqL1xuICAgIGxvY2FsaXplOiBsb2NhbGl6ZSxcbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIHNlY29uZCBhcmd1bWVudCBmb3Igc3RyLnJlcGxhY2UobG9jYWxpemVSZWdleCwgcmVwbGFjZXIpXG4gICAgICogYGlnbm9yZWAsIGBnbG9iYWxgIGFuZCBgKGRvdCwgbmFtZSlgIGFyZSBtdXR1YWxseSBleGNsdXNpdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCAtIHRoZSB3aG9sZSBtYXRjaCAoaWdub3JlZClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBpZ25vcmUgLSBhIGNvbW1lbnQgb3IgYSBzdHJpbmcgbGl0ZXJhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGdsb2JhbCAtIGEgZ2xvYmFsIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBkb3QgLSBlaXRoZXIgJy4nIGZvciBhIGxvY2FsIGNsYXNzIG5hbWUgb3IgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBuYW1lIC0gdGhlIG5hbWUgdG8gbG9jYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9jYWxpemVSZXBsYWNlcjogZnVuY3Rpb24gKG1hdGNoLCBpZ25vcmUsIGdsb2JhbCwgZG90LCBuYW1lKSB7XG4gICAgICByZXR1cm4gaWdub3JlIHx8IGdsb2JhbCB8fCBkb3QgKyBsb2NhbGl6ZShuYW1lKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHtcbiAgICBuczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHByZWZpeCA9ICdfXycrbmFtZS5yZXBsYWNlKC9cXFcrL2csICdfJykgKyAnXydcbiAgICAgIGlmICghb3duLmNhbGwobnNDYWNoZSwgcHJlZml4KSkge1xuICAgICAgICBuc0NhY2hlW3ByZWZpeF0gPSBtYWtlSW5zdGFuY2UocHJlZml4LCBzdWZmaXgsIGF0cnVsZUhhbmRsZXJzLCBuc0NhY2hlLCBiYWNrZW5kLCBzZXRQcm9wTGlzdClcbiAgICAgIH1cbiAgICAgIHJldHVybiBuc0NhY2hlW3ByZWZpeF1cbiAgICB9LFxuICAgIG5hbWVzOiBuYW1lcyxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICBzaGVldDogZnVuY3Rpb24odHJlZSkge3JldHVybiBpbnZva2UocnVsZXMsIHRyZWUsIHN0YXRlLCBiYWNrZW5kWzBdKX0sXG4gICAgaW5saW5lOiBmdW5jdGlvbiAodHJlZSkge3JldHVybiBpbnZva2UoZGVjbGFyYXRpb25zLCB0cmVlLCBzdGF0ZSwgYmFja2VuZFsxXSl9XG4gIH1cbiAgZm9yICh2YXIgaSA9IHNldFByb3BMaXN0Lmxlbmd0aDsgaS0tOykgZGVmYXVsdHMoaW5zdGFuY2UsIHNldFByb3BMaXN0W2ldKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSjJjKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgLy8gdGhlIGJ1ZmZlciB0aGF0IGFjY3VtdWxhdGVzIHRoZSBvdXRwdXQuIEluaXRpYWxpemVkIGluIGAkc2luay5pbml0KClgXG4gIHZhciBidWYsIGVyclxuXG4gIC8vIHRoZSBkZWZhdWx0IHNpbmsuXG4gIHZhciBfYmFja2VuZCA9IFt7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge2J1Zj1bXSwgZXJyPVtdfSxcbiAgICBkb25lOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgICBpZiAoZXJyLmxlbmd0aCAhPSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2oyYyBlcnJvcihzKTogJyArIEpTT04uc3RyaW5naWZ5KGVycixudWxsLDIpICsgJyBpbiBjb250ZXh0OlxcbicgKyBidWYuam9pbignJykpXG4gICAgICByZXR1cm4gcmF3ID8gYnVmIDogYnVmLmpvaW4oJycpXG4gICAgfSxcbiAgICBlcnI6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGVyci5wdXNoKG1zZylcbiAgICAgIGJ1Zi5wdXNoKCcvKiArKysgRVJST1IgKysrICcgKyBtc2cgKyAnICovXFxuJylcbiAgICB9LFxuICAgIHJhdzogZnVuY3Rpb24gKHN0cikge2J1Zi5wdXNoKHN0ciwgJ1xcbicpfSxcbiAgICBhdHJ1bGU6IGZ1bmN0aW9uIChydWxlLCBraW5kLCBwYXJhbSwgdGFrZXNCbG9jaykge1xuICAgICAgYnVmLnB1c2gocnVsZSwgcGFyYW0gJiYgJyAnLCBwYXJhbSwgdGFrZXNCbG9jayA/ICcge1xcbicgOiAnO1xcbicpXG4gICAgfSxcbiAgICAvLyBjbG9zZSBhdHJ1bGVcbiAgICBfYXRydWxlOiBmdW5jdGlvbiAoKSB7YnVmLnB1c2goJ31cXG4nKX0sXG4gICAgcnVsZTogZnVuY3Rpb24gKHNlbGVjdG9yKSB7YnVmLnB1c2goc2VsZWN0b3IsICcge1xcbicpfSxcbiAgICAvLyBjbG9zZSBydWxlXG4gICAgX3J1bGU6IGZ1bmN0aW9uICgpIHtidWYucHVzaCgnfVxcbicpfSxcbiAgICBkZWNsOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtidWYucHVzaChwcm9wLCAnOicsIHZhbHVlLCAnO1xcbicpfVxuICB9XVxuXG4gIC8vIGhvbGRzIHRoZSBgX2ZpbHRlcmAgYW5kIGBhdHJ1bGVgIGhhbmRsZXJzXG4gIHZhciBfZmlsdGVycyA9IFtjbG9zZVNlbGVjdG9yc11cbiAgdmFyIF9hdHJ1bGVIYW5kbGVycyA9IFtdXG4gIHZhciBfc2V0UHJvcExpc3QgPSBbXVxuICB2YXIgX3N1ZmZpeCA9IHJhbmRDaGFycyg3KVxuICB2YXIgX25zQ2FjaGUgPSB7fVxuXG4gIC8vIHRoZSBwdWJsaWMgQVBJIChzZWUgdGhlIG1haW4gZG9jcylcblxuXG4gIC8vIGhhbmRsZXIgb3B0aW9uc1xuICBpZiAodHlwZS5jYWxsKG9wdGlvbnMucGx1Z2lucykgPT09IEFSUkFZKSB7XG4gICAgZmxhdEl0ZXIoZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICBpZiAodHlwZS5jYWxsKHBsdWdpbikgIT09IE9CSkVDVCkgdGhyb3cgbmV3IEVycm9yKCdiYWQgcGx1Z2luLCBvYmplY3QgZXhwZWN0ZWQsIGdvdCAnKyB0eXBlLmNhbGwocGx1Z2luKSlcblxuICAgICAgaWYgKHR5cGUuY2FsbChwbHVnaW4uZmlsdGVyKSA9PT0gRlVOQ1RJT04pIF9maWx0ZXJzLnB1c2gocGx1Z2luLmZpbHRlcilcbiAgICAgIGlmICh0eXBlLmNhbGwocGx1Z2luLmF0cnVsZSkgPT09IEZVTkNUSU9OKSBfYXRydWxlSGFuZGxlcnMucHVzaChwbHVnaW4uYXRydWxlKVxuICAgICAgaWYgKHR5cGUuY2FsbChwbHVnaW4uc2luaykgPT09IEZVTkNUSU9OKSBfYmFja2VuZCA9IHBsdWdpbi5zaW5rKClcbiAgICAgIGlmICh0eXBlLmNhbGwocGx1Z2luLnNldCkgPT09IE9CSkVDVCkgX3NldFByb3BMaXN0LnB1c2gocGx1Z2luLnNldClcbiAgICB9KShvcHRpb25zLnBsdWdpbnMpXG4gIH1cbiAgaWYgKHR5cGUuY2FsbChvcHRpb25zLnN1ZmZpeCkgPT09IFNUUklORykgX3N1ZmZpeCA9IG9wdGlvbnMuc3VmZml4XG4gIGlmICh0eXBlLmNhbGwob3B0aW9ucy5zdWZmaXgpID09PSBOVU1CRVIpIF9zdWZmaXggPSByYW5kQ2hhcnMob3B0aW9ucy5zdWZmaXgpXG5cbiAgX2JhY2tlbmRbMV0gPSBfYmFja2VuZFsxXSB8fCB7XG4gICAgaW5pdDogX2JhY2tlbmRbMF0uaW5pdCxcbiAgICBkb25lOiBfYmFja2VuZFswXS5kb25lLFxuICAgIHJhdzogX2JhY2tlbmRbMF0ucmF3LFxuICAgIGVycjogX2JhY2tlbmRbMF0uZXJyLFxuICAgIGRlY2w6IF9iYWNrZW5kWzBdLmRlY2xcbiAgfVxuXG4gIC8vIGZpbmFsaXplIHRoZSBiYWNrZW5kIGJ5IG1lcmdpbmcgaW4gdGhlIGZpbHRlcnNcbiAgZm9yKHZhciBpID0gMDsgaSA8IDI7IGkrKyl7IC8vIDAgZm9yIGoyYy5zaGVldCwgMSBmb3IgajJjLmlubGluZVxuICAgIGZvciAodmFyIGogPSBfZmlsdGVycy5sZW5ndGg7IGotLTspIHtcbiAgICAgIF9iYWNrZW5kW2ldID0gZnJlZXplKFxuICAgICAgICBkZWZhdWx0cyhcbiAgICAgICAgICBfZmlsdGVyc1tqXShfYmFja2VuZFtpXSwgISFpKSxcbiAgICAgICAgICBfYmFja2VuZFtpXVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG4gIHJldHVybiBmcmVlemUobWFrZUluc3RhbmNlKCcnLCBfc3VmZml4LCBfYXRydWxlSGFuZGxlcnMsIF9uc0NhY2hlLCBfYmFja2VuZCwgX3NldFByb3BMaXN0KSlcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxJQUNFLFdBQVcsR0FBRyxFQUFFO0lBQ2hCLElBQUksR0FBRyxXQUFXLENBQUMsUUFBUTtJQUMzQixLQUFLLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDdEIsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMvQixNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDdEIsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzFCLEdBQUcsSUFBSSxXQUFXLENBQUMsY0FBYztJQUNqQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUE7OztBQUdsRCxTQUFTLFFBQVEsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFO0VBQ2hDLEtBQUssSUFBSSxDQUFDLElBQUksTUFBTSxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDN0MsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUM1RDtFQUNELE9BQU8sTUFBTTtDQUNkOztBQUVELFNBQVMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7RUFDdEIsSUFBSSxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUE7RUFDbEIsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzVCLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUM1QixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtFQUN6QixPQUFPLEdBQUc7Q0FDWDs7Ozs7OztBQU9ELElBQUksaUJBQWlCLEdBQUcsNkRBQTZELENBQUE7Ozs7Ozs7Ozs7O0FBV3JGLFNBQVMsYUFBYSxDQUFDLFFBQVEsRUFBRTtFQUMvQixJQUFJLE9BQU8sR0FBRyxFQUFFLEVBQUUsR0FBRyxHQUFHLEVBQUUsRUFBRSxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQTs7RUFFMUMsT0FBTyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFOztJQUUzQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDWixLQUFLLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEtBQUs7SUFDMUIsS0FBSyxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFLO0lBQzFCLEtBQUssR0FBRyxFQUFFLElBQUksT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtLQUNsRDtHQUNGO0VBQ0QsS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUM1QixHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7SUFDM0MsUUFBUSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ3pDO0VBQ0QsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtFQUNyQixPQUFPLEdBQUc7Q0FDWDs7O0FBR0QsSUFBSSxrQkFBa0IsR0FBRyx5REFBeUQsQ0FBQTs7QUFFbEYsU0FBUyxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtFQUNyQyxJQUFJLE9BQU8sR0FBRyxFQUFFLEVBQUUsS0FBSyxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFBOztFQUVwQyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7O0lBRTVDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtHQUN2QztFQUNELEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDNUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBQzdDLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUN6QztFQUNELEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUE7RUFDdkIsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0VBQ3pDLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0VBQ2hCLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUNqQyxHQUFHLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ3JEO0VBQ0QsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztDQUNyQjs7QUFFRCxTQUFTLFFBQVEsRUFBRSxDQUFDLEVBQUU7RUFDcEIsT0FBTyxTQUFTLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFDeEIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEtBQUssRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDM0UsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ1o7Q0FDRjs7QUFFRCxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUE7QUFDZCxTQUFTLFNBQVMsQ0FBQyxDQUFDLEVBQUU7RUFDcEIsTUFBTSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFBO0VBQ3JGLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtFQUNqQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtFQUN0QixPQUFPLEdBQUc7Q0FDWCxBQUVEOztBQ2xHQSxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUU7RUFDekIsT0FBTyxHQUFHLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRTtDQUNqQzs7Ozs7Ozs7Ozs7Ozs7QUFjRCxBQUFPLFNBQVMsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUU7RUFDMUQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQTtFQUNaLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNOztFQUVuQixTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztFQUNuQyxLQUFLLEtBQUs7SUFDUixLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFOztNQUUzQixZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFBOztJQUVoRCxLQUFLO0VBQ1AsS0FBSyxNQUFNOzs7SUFHVCxNQUFNLEdBQUcsQ0FBQyxNQUFNLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFBO0lBQ2pDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQzlCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7TUFDUixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDaEIsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7O1VBRWxELFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFBOztTQUVwRDtPQUNGLE1BQU07O1FBRUwsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7O09BRWhEO0tBQ0Y7SUFDRCxLQUFLO0VBQ1A7Ozs7O0lBS0UsSUFBSSxDQUFDLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDOzs7Ozs7SUFNL0IsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUE7O0lBRTNELElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixJQUFJLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRTs7O01BR3hELENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRTs7UUFFaEMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLGtGQUFrRixFQUFFLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQzs7T0FFN0gsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtLQUNiOztJQUVELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0dBQ2hCO0NBQ0Y7O0FDckVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsQUFBTyxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUU7OztFQUd0RSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7O0lBRXBELElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxZQUFZLENBQUMsRUFBRSxNQUFNOztHQUVwRjs7Ozs7O0VBTUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFOztJQUVsQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQTs7O0dBRy9DLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFOztJQUV4QyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQTs7O0dBRy9DLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs7SUFFdkMsSUFBSSxDQUFDLEtBQUssSUFBSSxZQUFZLEVBQUUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLDJCQUEyQixHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFFL0UsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFFOUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUNOLFFBQVEsQ0FBQyxTQUFTLE9BQU8sRUFBRSxRQUFRLEVBQUU7O01BRW5DLEdBQUcsT0FBTyxJQUFJLElBQUksSUFBSSxDQUFDLGdEQUFnRCxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOztXQUVuSyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUE7O0tBRXpDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTs7O0lBR0wsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFO01BQ1osS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQTtNQUM5QyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtLQUN6Qzs7O0dBR0YsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGdDQUFnQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUMvRCxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7O01BRW5CLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTs7S0FFM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOzs7R0FHTixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksMEJBQTBCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQ3pELFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTs7TUFFbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQTs7TUFFckMsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQTs7TUFFdkMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFBOztLQUVmLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTs7R0FFTixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLHFDQUFxQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs7SUFFbkUsSUFBSSxLQUFLLElBQUksV0FBVyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUNoQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU87O1FBRWpCLDBFQUEwRTtRQUMxRSxLQUFLLENBQUMsZ0JBQWdCO09BQ3ZCLENBQUE7S0FDRjs7SUFFRCxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7O01BRWxCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUE7O01BRXJDLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7O0tBRXhDLE1BQU07O01BRUwsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQTs7TUFFckMsS0FBSztRQUNILEtBQUssRUFBRSxJQUFJO1FBQ1gsV0FBVyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTTtRQUNqQyxDQUFDLEVBQUUsS0FBSyxFQUFFLFlBQVksR0FBRyxDQUFDO09BQzNCLENBQUE7O0tBRUY7O0lBRUQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFBOztHQUVmLE1BQU07O0lBRUwsSUFBSSxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTs7R0FFekM7Q0FDRjs7QUMzSEQ7Ozs7Ozs7Ozs7O0FBV0EsQUFBTyxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRTtFQUNwRSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsQ0FBQTs7RUFFM0IsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzs7RUFFdkIsS0FBSyxNQUFNO0lBQ1QsS0FBSyxDQUFDLElBQUksSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUU7TUFDckMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTs7TUFFWCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDNUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtVQUNsQixhQUFhLEdBQUcsQ0FBQyxDQUFBOztVQUVqQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBOztTQUVsQjtRQUNELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtVQUNoQixLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTs7WUFFbEQsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQTs7V0FFM0M7U0FDRixNQUFNOztVQUVMLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7O1NBRXZDOztPQUVGLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFOztRQUV2QixhQUFhLEdBQUcsQ0FBQyxDQUFBOztRQUVqQixPQUFPLENBQUMsS0FBSyxFQUFFLElBQUk7VUFDakIsc0RBQXNELENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1VBQy9FLENBQUMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFlBQVk7U0FDL0IsQ0FBQTs7T0FFRixNQUFNOztRQUVMLGFBQWEsR0FBRyxDQUFDLENBQUE7O1FBRWpCLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRTtVQUNaLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtVQUNaLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQTtVQUMvQixRQUFRO1NBQ1Q7O1FBRUQsS0FBSztVQUNILEtBQUssRUFBRSxJQUFJOzs7a0JBR0gsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOzt1QkFFbkQsQ0FBQyxFQUFFLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFLGFBQWE7Y0FDbkQsS0FBSzs7Z0JBRUgsQ0FBQyxDQUFDLE9BQU87a0JBQ1Asd0hBQXdIO2tCQUN4SCxLQUFLLENBQUMsZ0JBQWdCO2lCQUN2Qjs7Z0JBRUQsQ0FBQzthQUNKLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFO2NBQ2pCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLEVBQUU7Z0JBQzFELE9BQU8sRUFBRSxHQUFHLENBQUM7ZUFDZCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQzthQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7O2dDQUVPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzt5QkFFbEIsU0FBUztnQkFDbEIsS0FBSzs7a0JBRUgsQ0FBQyxDQUFDLE9BQU87b0JBQ1Asd0hBQXdIO29CQUN4SCxLQUFLLENBQUMsZ0JBQWdCO21CQUN2Qjs7a0JBRUQsQ0FBQztnQkFDSCxDQUFDLE1BQU0sQ0FBQztlQUNUOzt5QkFFVSxNQUFNLEdBQUc7Z0JBQ2xCLEtBQUs7O2tCQUVILENBQUMsQ0FBQyxPQUFPO29CQUNQLHdIQUF3SDtvQkFDeEgsS0FBSyxDQUFDLGdCQUFnQjttQkFDdkI7O2tCQUVELENBQUM7aUJBQ0Y7V0FDTixDQUFDLEVBQUUsS0FBSyxFQUFFLFlBQVksR0FBRyxDQUFDO1NBQzVCLENBQUE7O09BRUY7S0FDRjs7SUFFRCxLQUFLOztFQUVQLEtBQUssS0FBSztJQUNSLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQzs7TUFFL0IsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUE7O0tBRXpEO0lBQ0QsS0FBSzs7RUFFUCxLQUFLLE1BQU07OztJQUdULElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBOztJQUVwQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBOztHQUVmO0NBQ0Y7Ozs7Ozs7Ozs7O0FBV0QsQUFBTyxTQUFTLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFO0VBQzNDLElBQUksWUFBWSxDQUFBO0VBQ2hCLE9BQU8sTUFBTSxHQUFHLElBQUksR0FBRztJQUNyQixJQUFJLEVBQUUsVUFBVSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUEsQ0FBQztJQUNoRCxJQUFJLEVBQUUsWUFBWTtNQUNoQixJQUFJLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUEsQ0FBQztNQUNuRCxPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUU7S0FDbkI7SUFDRCxNQUFNLEVBQUUsVUFBVSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUU7TUFDL0MsSUFBSSxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFBLENBQUM7TUFDbkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQTtLQUMzQztJQUNELE9BQU8sRUFBRSxVQUFVLElBQUksRUFBRTtNQUN2QixJQUFJLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUEsQ0FBQztNQUNuRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO0tBQ25CO0lBQ0QsSUFBSSxFQUFFLFVBQVUsUUFBUSxFQUFFO01BQ3hCLElBQUksUUFBUSxLQUFLLFlBQVksQ0FBQztRQUM1QixJQUFJLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUNuQixZQUFZLEdBQUcsUUFBUSxDQUFBO09BQ3hCO0tBQ0Y7SUFDRCxLQUFLLEVBQUUsVUFBVTtNQUNmLElBQUksWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQSxDQUFDO0tBQ3BEO0dBQ0Y7Q0FDRjs7QUNyS0QsU0FBUyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFO0VBQ3hDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQTtFQUNkLEdBQUc7SUFDRCxFQUFFO01BQ0EsS0FBSztNQUNMLE9BQU87TUFDUCxFQUFFO01BQ0YsSUFBSTtNQUNKLENBQUM7TUFDRCxDQUFDO0tBQ0YsQ0FBQTtHQUNGLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUEsQ0FBQztFQUMvRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLEVBQUU7Q0FDdEI7O0FBRUQsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUU7RUFDbkYsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFBO0VBQ2QsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFO0lBQ3RCLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksR0FBRyxNQUFNLENBQUE7SUFDaEUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztHQUNqQztFQUNELElBQUksS0FBSyxJQUFJO0lBQ1gsY0FBYyxFQUFFLGNBQWM7SUFDOUIsS0FBSyxFQUFFLEtBQUs7Ozs7Ozs7O0lBUVosUUFBUSxFQUFFLFFBQVE7Ozs7Ozs7Ozs7OztJQVlsQixnQkFBZ0IsRUFBRSxVQUFVLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUU7TUFDNUQsT0FBTyxNQUFNLElBQUksTUFBTSxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO0tBQ2hEO0dBQ0YsQ0FBQTs7RUFFRCxJQUFJLFFBQVEsR0FBRztJQUNiLEVBQUUsRUFBRSxTQUFTLElBQUksRUFBRTtNQUNqQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFBO01BQ2pELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRTtRQUM5QixPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUE7T0FDOUY7TUFDRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUM7S0FDdkI7SUFDRCxLQUFLLEVBQUUsS0FBSztJQUNaLE1BQU0sRUFBRSxNQUFNO0lBQ2QsTUFBTSxFQUFFLE1BQU07SUFDZCxLQUFLLEVBQUUsU0FBUyxJQUFJLEVBQUUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyRSxNQUFNLEVBQUUsVUFBVSxJQUFJLEVBQUUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUMvRSxDQUFBO0VBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7RUFDekUsT0FBTyxRQUFRO0NBQ2hCOztBQUVELEFBQWUsU0FBUyxHQUFHLENBQUMsT0FBTyxFQUFFO0VBQ25DLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFBOztFQUV2QixJQUFJLEdBQUcsRUFBRSxHQUFHLENBQUE7OztFQUdaLElBQUksUUFBUSxHQUFHLENBQUM7SUFDZCxJQUFJLEVBQUUsWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQSxDQUFDO0lBQ2xDLElBQUksRUFBRSxVQUFVLEdBQUcsRUFBRTtNQUNuQixJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7TUFDckgsT0FBTyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0tBQ2hDO0lBQ0QsR0FBRyxFQUFFLFVBQVUsR0FBRyxFQUFFO01BQ2xCLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7TUFDYixHQUFHLENBQUMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQTtLQUM5QztJQUNELEdBQUcsRUFBRSxVQUFVLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFBLENBQUM7SUFDekMsTUFBTSxFQUFFLFVBQVUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFO01BQy9DLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssSUFBSSxHQUFHLEVBQUUsS0FBSyxFQUFFLFVBQVUsR0FBRyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUE7S0FDakU7O0lBRUQsT0FBTyxFQUFFLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUM7SUFDdEMsSUFBSSxFQUFFLFVBQVUsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUEsQ0FBQzs7SUFFdEQsS0FBSyxFQUFFLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUM7SUFDcEMsSUFBSSxFQUFFLFVBQVUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUEsQ0FBQztHQUNqRSxDQUFDLENBQUE7OztFQUdGLElBQUksUUFBUSxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUE7RUFDL0IsSUFBSSxlQUFlLEdBQUcsRUFBRSxDQUFBO0VBQ3hCLElBQUksWUFBWSxHQUFHLEVBQUUsQ0FBQTtFQUNyQixJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUE7RUFDMUIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFBOzs7Ozs7RUFNakIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxLQUFLLEVBQUU7SUFDeEMsUUFBUSxDQUFDLFNBQVMsTUFBTSxFQUFFO01BQ3hCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxNQUFNLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztNQUV6RyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLFFBQVEsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtNQUN2RSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLFFBQVEsRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtNQUM5RSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLFFBQVEsRUFBRSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFBO01BQ2pFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssTUFBTSxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0tBQ3BFLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUE7R0FDcEI7RUFDRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRSxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQTtFQUNsRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRSxPQUFPLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQTs7RUFFN0UsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSTtJQUMzQixJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7SUFDdEIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO0lBQ3RCLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRztJQUNwQixHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUc7SUFDcEIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO0dBQ3ZCLENBQUE7OztFQUdELElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDeEIsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHO01BQ2xDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNO1FBQ2xCLFFBQVE7VUFDTixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDN0IsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUNaO09BQ0YsQ0FBQTtLQUNGO0dBQ0Y7RUFDRCxPQUFPLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztDQUM1Riw7Oyw7OyJ9